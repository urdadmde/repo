\section{Internal consistency of the URDAD methodology}
\label{sec:urdadConsistency}

In oder to validate the internal consistency of the URDAD methodology, we used URDAD to design the service of performing a services-oriented analysis and design. If the methodology is consistent it needs to either regenerate itself or at least something which is largely equivalent to itself. 

Due to space constraints we cannot go through the full process across levels of granularity. Instead we demonstrate the consistency by looking at a particular level of granularity and point out how URDAD starts regenerating itself as process and how its own metamodel is regenerated. We also use this opportunity to show aspects of the URDAD metamodel and the text grammar of the URDAD-DSL\footnote{A separate paper discussing the URDAD metamodel and domain specific language for URDAD is currently being reviewed.}. To make this more interesting we omit the first level of granularity which is a process which contains the analysis and process design steps for a particular level of granularity. We zoom directly into the \emph{performAnalysis} service which has more interesting pre- and post-conditions and consequently a more interesting process specification.

\begin{figure}[Htbp]
  \centering
  \includegraphics{contract}
  \caption{The modeling constructs available in URDAD introducing the semantics for services contracts}
  \label{fig:contractModule}
\end{figure}

We start by eliciting the stakeholders (yielding the stakeholders identified in section \ref{sec:qualityRequirements}) and their functional requirements. The output is a service contract specification for the \emph{performAnalysis} service which itself contains the concept of a service contract. The URDAD metamodel support for service contract specification is shown in figure \ref{fig:contractModule}. Below we use the text grammar defined for the URDAD-DSL to specify the service contract for the \emph{performAnalysis} service:

\lstset{language=urdad,caption=Specifying a state constraint in the URDAD text grammar.,label=contractTextSyntax}
\begin{lstlisting}[numbers=left,escapechar=|]
ResponsibilityDomain Analysis
{
  ...
  ServiceContract performAnalysis 
  {
    FunctionalRequirements receiving Variable performAnalysisRequest ofType PerformAnalysisRequest yielding Variable performAnalsysiResult ofType PerformAnalysisResult
    {
      PreCondition serviceHasStakeholders requiredBy (Client) raises NoStakeholdersException checks Constraint ServiceHasStakeholders with Query OCL:"performAnalaysisRequest.serviceRequirements"
      PreCondition stakeholderRequirementsConsistent requiredBy (Client Development Architecture Testing) raises InconsistentStakeholderRequirementsException checks Constraint StakeholderRequirementsConsistent with Query OCL:"performAnalysisResult.serviceContract"
      PostCondition serviceContractSpecified requiredBy (Client Development Architecture Testing) ensures Constraint ServiceContractSpecified with Query OCL:"performAnalysisResult"
      PostCondition serviceContractAssignedToResponsibilityDomain requiredBy (Client) ensures Constraint ServiceContractAssignedToResponsibilityDomain with Query OCL:"performAnalysisResult.serviceContract"
    }
    Request DataStructure PerformAnalysisRequest
    {
      has Component serviceRequirements ofType _ServiceRequirements
      has many Identification stakeholders identifying _Stakeholder
    }
    Result DataStructure PerformAnalysisResult
    {
      has Component serviceContract ofType _ServiceContract
    }
  }
}
\end{lstlisting}

Note how we are already regenerating the URDAD metamodel in that the \verb+ServiceContract+ for perform analysis generates a domain which includes the concept of a \verb+_ServiceContract+. As we follow the URDAD methodology to design itself, we traverse levels of granularity, incrementally generating lower level aspects of the URDAD process and the URDAD metamodel, populating the finer details in the metamodel classes and the lower level process elements of the URDAD process. Throughout the classes without underscore prefix are the metamodel classes whilst the classes with underscore prefix are the classes generated by the methodology itself. 

\lstset{language=urdad,caption=Regenerated metamodel classes.,label=constraintTextSyntax}
\begin{lstlisting}[numbers=left,escapechar=|]
DataStructure _ServiceContract 
{
    has Component functionalRequirements ofType _FunctionalRequirements
    has Component request ofType _DataStructure
    has Component result ofType _DataStructure
}
\end{lstlisting}

\begin{figure}[Htbp]
  \centering
  \includegraphics{constraint}
  \caption{The modeling constructs available in URDAD facilitating the specification of constraints.}
  \label{fig:constraintModule}
\end{figure}

Service contracts refers to reusable, parametrized state constraints. Figure \ref{fig:constraintModule}, shows URDAD's modeling elements for specifying such constraints. In a separate paper currently under review we have pointed out that the Object-Constraint Language (OCL)\cite{_object_2010}  alone is not expressive enough to specify reusable, parametrized constraints for a services oriented approach where one needs to extract information from the environment via services and then apply data structure constraints on the obtained environmental information.

The following listing shows an simple example of a parametrized constraint, \emph{ServiceHasStakeholders}, which demonstrated that a state constraint is assembled from a process that extracts information from the environment and a set of data constraints applied to the obtained information.
\lstset{language=urdad,caption=Specifying a state constraint in the URDAD text grammar.,label=processTextSyntax}
\begin{lstlisting}[numbers=left,escapechar=|]
StateConstraint ServiceHasStakeholders receiving Variable serviceRequirements ofType _ServiceRequirements 
{
  StateAssessmentProcess doSequential 
  {
    create Variable identifyStakeholdersRequest ofType IdentifyStakeholdersRequest
    set Query OCL:"identifyStakeholdersRequest.serviceRequirements" equalTo Query OCL:"serviceRequirements"
    requestService identifyStakeholders with identifyStakeholdersRequest yielding Variable identifyStakeholdersResult ofType IdentifyStakeholdersResult
  }
  Constraint OCL:"identifyStakeholdersResult->size() > 0"
}
\end{lstlisting}

\begin{figure}[Htbp]
  \centering
  \includegraphics{process}
  \caption{The modeling constructs available for specifying services and processes in URDAD}
  \label{fig:processModule}
\end{figure}

Finally we use URDAD to design its analysis process. For this we use the URDAD modeling constructs for process specification shown in figure \ref{fig:processModule} (of course via the URDAD-DSL text grammar). Note that, following the URDAD process discussed in \ref{sec:urdadProcess} we first specify the services we want to use to address each of the functional requirements (the \verb+usedToAddress+ links between a service requirement and a functional requirement represents the satisfaction links of \cite{ramesh_toward_2001}) before choreographing the process across these services. 

The following listing is an excerpt of the URDAD analysis process generated by applying URDAD to design the \verb+performAnalysis+ service:
\lstset{language=urdad,caption=Specifying the performAnalysis service in the textual URDAD DSL syntax.,label=serviceTextSyntax}
\begin{lstlisting}[numbers=left,escapechar=|]
Service performAnalysisImpl realizes performAnalysis receiving Variable performAnalysisRequest ofType PerformAnalysisRequest 
{
  use identifyStakeholders toAddress (serviceHasStakeholders) 
  use specifyServiceContract toAddress (stakeholderRequirementsConsistent serviceContractSpecified)
  use assignServiceContractToResponsibilityDomain toAddress (serviceContractAssignedToResponsibilityDomain)
 
  Process doSequential
  {
    create Variable identifyStakeholdersRequest ofType IdentifyStakeholdersRequest
    set Query OCL:"identifyStakeholdersRequest.serviceRequirements" equalTo Query OCL:"performAnalysisRequest.serviceRequirements"
    
    requestService identifyStakeholders with identifyStakeholdersRequest yielding Variable identifyStakeholdersResult ofType IdentifyStakeholdersResult on NoStakeholdersException raiseException NoStakeholdersException

    ...
    requestService specifyServiceContract ...
    ...
    requestService assignServiceContractToResponsibilityDomain ...
    ...
    create Variable performAnalysisResult ofType PerformAnalysisResult
    set Query OCL:"performAnalysisResult.serviceContract" equalTo Query OCL:"specifyServiceContractResult.serviceContract"  
  }                              
}
\end{lstlisting}

Comparing the above listing we see that \emph{performAnalysis} process corresponds to the original process discussed in section \ref{sec:urdadProcess}.