\section{Quality drivers}
\label{sec:qualityDrivers}

A quality drivers is defined as an activity which improves one or more process or model quality criteria\cite{petersen_software_1989}. The relience on quality-drivers forms the basis for the concept of a \emph{`quality-driven'} process. In this section we look at each model and process quality criterion and discuss activities (quality drivers) which can be used to improve the quality criterion. The list of quality-drivers presented here is not intended to be exhaustive but includesrepresents a collection of quality-drivers which are widely known and used. In addition to identifying quality-drivers, we also note that quality metrics can be applied to the resultant model in order to assess model quality. This section discusses some commonly used quality metrics for the identified quality criteria suitable for a service-oriented approach. For a more general list of model quality metrics the reader should consult \cite{mohagheghi_existing_2009}.

\subsection{Model quality drivers}

\emph{Semantic Model Quality} relates to semantic accuracy and completeness. It is influenced by the quality of the modeling language and hence by the semantic quality of the metamodel of the modeling language. The latter is determined by its semantic completeness, consistency and complexity\cite{buder_effects_2010}. Semantic completeness refers to the power of the formal language to express all propositions. More precisesly, a formal system is said to be semantically complete if and only if every theorem of the system is provable in the system.  A core semantic quality-driver is thus the specification of a metamodel for the analysis and design model which itself is shown to be semantically complete and consistent.

\emph{Syntactic Quality} elates to correct language usage\cite{lange_christiaan_assessing_2007}, i.e.\ that the grammatical statements made comply to the abstract syntax as specified via the metamodel and its constraints or an ontology and its associated rules. A commonly used syntactic quality driver is the definition of concrete text and/or graphical grammars and a transformation between the concrete and abstract syntax. Models which are defined through and verified against the concrete syntax can be shown to comply to the abstract syntax of the associated metamodel. Editors generated from the concrete syntax definition generally validate syntactic correctness. In this paper we confine the assessment of syntactic quality to the existence of a formal modeling language and concrete grammar for model specification. We will thus assume that model instances will adhere to the grammar of the chosen modeling language as this can easily be verified.

\emph{Simplicity} is the inverse of complexity. The complexity of the modeling language is usually assessed by measuring the complexity of the metamodel for that language\cite{mohagheghi_evaluating_2007}. A lot of work has been done on model complexity itself. Common approaches include using information entropy measures\cite{abrahamsson_extreme_2004}, language-theoretic approaches\cite{podgorelec_estimating_2007} and function complexity assessment based on the McCabe complexity measure \cite{mccabe_complexity_1976}. A service-oriented approach already enforces certain drivers for simplicity. In particular it enforces the assembling of functions from independent, stateless services, the enforced decoupling through services contracts, the improved reuse through the implied service discovery, as well as an implied adapter layer facilitating reuse across technologies and interfaces mismatches. A metamodel confining the modeling constructs and relationships between these, as well as a convenient grammar, reduce complexity. Another core driver for simplicity is the decomposition across levels of granularity enabling the understanding and processing of one level of granularity before having to concern oneself with the details of the next lower level of granularity. The availability of a services contract enables one to look at a service from a user/service consumer perspective before understanding the service function. Finally, traceability links and in particular enforced satisfaction links (i.e.\ that a functions may only use services which address functional requirements of the service) are drivers for simplicity.

\emph{Completeness} of requirements is difficult to assess, though the discovery of certain stakeholders for which no functional or non-functional requirements exist is an indication of missing requirements. Design completeness is easier to assess as there is a global point of reference - the degree to which the requirements are fulfilled. Core quality-drivers for completeness include enforced satisfaction links, the enforcement of testable pre- and post-conditions, as well as having a metamodel which enforces certain content, either structurally, or through metamodel constraints. In a service-oriented approach, a completeness metric can be specified as a function of 1) the percentage of functional requirements not addressed in the designed functions (identified through missing satisfaction links)\cite{shim_design_2008}, 2) the fraction of pre- and post-conditions for which the test process has not been specified and 3) the percentage of request and result classes for which the data structures have not been specified. At the implementation level completeness can be assessed as the fraction of services for which service implementations are not yet available.

\emph{Consistency} is an important model property. A lot of emphasis has been placed on model consistency for UML models. This is so because UML models are often inconsistent due to the multi-diagram approach and the complexity of the modeling language itself\cite{lange_empirical_2004}. A commonly quality-driver for model consistency is to use a much smaller (less general) language with more formally defined semantics which enforces the consistency through both, its structure and a set of metamodel constraints.

\emph{Cohesion} in a service-oriented approach has been extensively studied by Mikhael Perepletchikov et al.\ \cite{perepletchikov_cohesion_2007,perepletchikov_impact_2010}. Their approach is closely related to that of unity criteria \cite{gonzalez_unity_2009} identifying and quantifying interfacing cohesion, usage cohesion and implementation cohesion. These cohesion measures can be applied directly to an URDAD model. Quality-drivers for cohesion include enforcing the single responsibility principle as well as localizing all controll and decision logic for a service in a controller service. 

\emph{Decoupling} is enforced in a service-oriented approach by requiring that services are only consumed via services contracts. This decouples services across levels of granularity. Quality-drivers for decoupling include a metamodel which enforces contracts based decoupling through metamodel structure and localization of function logic within a controller. The latter ensures that lower level services remain decoupled, i.e.\ that they do not call each other. In a service-oriented architecture, the number of services which are directly coupled to concrete lower level services can be used as a measure of coupling\cite{shim_design_2008}.

\emph{Modifiability} refers to the efficiency with which model changes can be applied, i.e.\ it is related to the inverse of the cost required to make model changes. Modifiability is difficult to quantitatively measure. It is supported by other model qualities like \emph{simplicity},  \emph{decoupling} (modifiability through pluggability), and \emph{cohesion} (localized maintenance). A further quality-driver in the form of localizing function logic within a controller service, thereby projecting out additional levels of granularity. Shim et al.\ \cite{shim_design_2008} define a quality metric for modifiability (flexibility) of service-oriented designs as a weighted sum of coupling, service granularity, and parameter granularity. Since increased complexity and coupling reduce modifiability, the quality drivers for simplicity and decoupling are also quality drivers for modifiability.

\emph{Reusability} provides a measure of the ability and likelihood that a service can be reused. Khoshkbarforoushha et al.\  \cite{khoshkbarforoushha_metric_2010,choi_quality_2008,feuerlicht_determinants_2007}
\cite{khoshkbarforoushha_metric_2010} point out that service reusability is often caused by contract and requirements mismatch. The former can be addressed via adapters. Core quality-drivers for reusability include \emph{decoupling} via services contracts with the latter also driving discoverability and consumability, \emph{levels of granularity} via process localization within a reusable controller service, and \emph{cohesion} through enforcing the single responsibility principle. Indeed, \cite{shim_design_2008} defines a simple quantitative reusability measure for service-oriented systems as a weighted sum of coupling, cohesion, granularity, and consumability.

\emph{Traceability} is needed for design validation and estimation. Validation includes assessing sufficiency and necessity. Ramesh and Jarke \cite{ramesh_toward_2001} identify four types of traceability links in models including \emph{satisfaction} links used to assess whether requirements are satisfied, \emph{evolutionary} links to trace along the evolution of an artifact over time, \emph{rationale} links which typically link requirements to higher level business goals, and \emph{dependency} links enabling one to identify dependencies of model elements. Quality-drivers include thus the availability of these traceability links in the modeling language and their enforced usage through the modeling process.