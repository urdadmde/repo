\section{Quality drivers and quality measures}
\label{sec:qualityDriversAndMetrics}

Quality-drivers are process activities which increase model and process qualities. The relience on quality-drivers \cite{petersen_software_1989} forms the basis for the concept of a \emph{`quality-driven'} process. In this section we look at each model and process quality requirement and discuss activities (quality drivers) which can be used
The list of quality-drivers presented here is not intended to be exhaustive. It is purely a collection of quality-drivers which are widely known and used. In addition to identifying quality-drivers, we also note that quality metrics can be applied to the resultant model in order to assess model quality. This section discusses some commonly used quality metrics for the identified quality requirements suitable for a services-oriented approach. For a more general list of model quality metrics the reader should consult \cite{mohagheghi_existing_2009}.

\subsection{Model quality drivers}

\emph{Semantic Model Quality} is a measure of the accuracy and completeness of the meaning conveyed with the analysis and design model. It is influenced by the quality of the modeling language. Semantic quality-drivers include the specification of a metamodel for the analysis and design model. The semantic quality is determined by the semantic completeness, consistency and complexity of the metamodel \cite{buder_effects_2010}. Semantic completeness refers to the power of the formal language to express all propositions, i.e.\ its ability to convey all meaning which needs to be conveyed. 

\emph{Syntactic Quality} is a measure of correct language usage\cite{lange_christiaan_assessing_2007}, i.e.\ that the grammatical statements made comply to the abstract syntax as specified via the metamodel and its constraints or an ontology and its associated rules. A commonly used syntactic quality driver is the definition of concrete text and/or graphical grammars and a transformation between the concrete and abstract syntax. Models which are defined through and verified against the concrete syntax can be shown to comply to the abstract syntax of the associated metamodel. Editors generated from the concrete syntax definition generally validate syntactic correctness. In this paper we confine the assessment of syntactic quality to the existence of a formal modeling language and concrete grammar for model specification. We will thus assume that model instances will adhere to the grammar of the chosen modeling language as this can easily be verified. Syntactic quality can be measured as a ratio of the number of statements without syntax errors relative to the total number of statements elements in the model. Thus, if $\cal{E}$ is the set of errors and $\cal{S}$ is the set of all Statements in the model, then the syntactic quality $Q_{syntax}$ is defined by
\begin{equation}
  Q_{syntax} = \frac{|\cal{S}| - |\cal{E}|}{|\cal{S}|}
\end{equation}

\emph{Simplicity} is a measure of lack of complexity. The complexity of the modeling language is usually assessed by measuring the complexity of the metamodel for that language\cite{mohagheghi_evaluating_2007}. A lot of work has been done on model complexity itself. Common approaches include using information entropy measures\cite{abrahamsson_extreme_2004}, language-theoretic approaches\cite{podgorelec_estimating_2007} and process complexity assessment based on the McCabe complexity measure \cite{mccabe_complexity_1976}. A services-oriented approach already enforces certain drivers for simplicity. In particular the assembling of processes from independent, stateless services, the enforced decoupling through services contracts, the improved reuse through the implied service discovery, as well as an implied adapter layer facilitating reuse across technologies and interfaces mismatches. A metamodel confining the modeling constructs and relationships between these, as well as a convenient grammar, reduce complexity. Another core driver for simplicity is the decomposition across levels of granularity enabling the understanding and processing of one level of granularity before having to concern oneself with the details of the next lower level of granularity. The availability of a services contract enables one to look at a service from a user/service consumer perspective before understanding the service process. Finally, traceability links and in particular enforced satisfaction links (i.e.\ that a process may only use services which address functionality) are drivers for simplicity. The field of complexity metrics is large and varied with most complexity metrics applicable to an URDAD model. URDAD does not suggest a particular metric. cite{wirfs-brock2007 towards design simplicity}

\emph{Completeness} is a measure of the lack of missing information in the analysis and design model. Completeness of requirements is difficult to assess, though the discovery of certain stakeholders for which no functional or non-functional requirements exist is an indication of missing requirements. Design completeness is easier to assess as there is a global measure - the degree to which the requirements are realized. Core quality-drivers for completeness include enforced satisfaction links, the enforcement of testable pre- and post-conditions, as well as having a metamodel which enforces certain content, either structurally, or through metamodel constraints. In a service-oriented approach, a completeness metric can be specified as a function of 1) the percentage of functional requirements not addressed in the designed processes (identified through missing satisfaction links)\cite{shim_design_2008}, 2) the fraction of pre- and post-conditions for which the test process has not been specified and 3) the percentage of request and result classes for which the data structures have not been specified. At the implementation level completeness can be assessed as the fraction of services for which service implementations are not yet available.

\emph{Consistency} is an important model quality measure. A lot of emphasis has been placed on model consistency for UML models. This is so because UML models are often inconsistent due to the multi-diagram approach and the complexity of the modeling language itself\cite{}. A commonly used quality-driver for model consistency is to use a much smaller (less general) language with more formally defined semantics which enforces the consistency through both, its structure and a set of metamodel constraints.

\emph{Cohesion} in a service-oriented approach has been extensively studied by Mikhael Perepletchikov et al.\ \cite{perepletchikov_cohesion_2007,perepletchikov_impact_2010}. Their approach is narrowly related to that of unity criteria \cite{gonzalez_unity_2009} identifying and quantifying interfacing cohesion, usage cohesion and implementation cohesion. These cohesion measures can be applied directly to an URDAD model. Quality-drivers for cohesion include enforcing the single responsibility principle as well as process localization within a controller service. 

\emph{Decoupling} is enforced in a services-oriented approach by requiring that services are only consumed via services contracts. This decouples services across levels of granularity. Quality-drivers for decoupling include a metamodel which enforces contracts based decoupling through metamodel structure or constraints and localization of process logic within a controller so that the service providers of the lower level services remain decoupled. In a services-oriented architecture, the number of services which are directly coupled to concrete lower level services can be used as a measure of coupling\cite{shim_design_2008}.

\emph{Modifiability} refers to the efficiency with which model changes can be applied, i.e.\ it is an inverse measure of the cost required to make model changes. Modifiability is difficult to quantitatively measure, but it is supported by other model qualities like \emph{simplicity},  \emph{decoupling} (modifiability through pluggability), and \emph{cohesion} (localized maintenance) and with a further quality-driver in the form of localizing process logic within a controller service, thereby projecting out additional levels of granularity. \cite{shim_design_2008} defines a quality metric for modifiability (flexibility) of services-oriented designs as a weighted sum of coupling, service granularity, and parameter granularity. We feel that simplicity (or complexity) and decoupling should also be included in the quality measure for modifiability.

\emph{Reusability} provides a measure of the ability and likelihood that a service can be reused.  \cite{khoshkbarforoushha_metric_2010,choi_quality_2008,feuerlicht_determinants_2007}
\cite{khoshkbarforoushha_metric_2010} point out that service reusability is impedded by contract and requirements mismatch. The former can be addressed via adapters. Core quality-drivers for reusability include \emph{decoupling} via services contracts with the latter also driving discoverability and consumability, \emph{levels of granularity} via process localization within a reusable controller service, and \emph{cohesion} through enforcing the single responsibility principle. Indeed, \cite{shim_design_2008} defines a simple quantitative reusability measure for service-oriented systems as a weighted sum of coupling, cohesion, granularity, and consumability.

\emph{Traceability} is required for design validation and estimation. Validation includes assessing sufficiency and necessity. \cite{ramesh_toward_2001} identifies four types of traceability links in models including \emph{satisfaction} links used to assess whether requirements are satisfied, \emph{evolutionary} links to trace along the evolution of an artifact over time, \emph{rationale} links which typically link requirements to higher level business goals, and \emph{dependency} links enabling one to identify dependencies of model elements. Quality-drivers include thus the availability of these traceability links in the modeling language and their enforced usage through the modeling process.