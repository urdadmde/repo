\section{Overview of the URDAD Methodology 
\label{sec:urdadMethodology}}

URDAD is currently a \emph{semi}-formal methodology for requirements elicitation in the form of technology-neutral business processes \cite{solms_urdad_2010}; its formalisation is the topic of ongoing research. \emph{Business processes} are specified as services with corresponding service contracts and process flows. The URDAD methodology stipulates a repeatable engineering workflow on the basis of the following iterated steps: service contract specification, responsibility allocation, and process design. The methodology envisages requirements specialists across responsibility domains to contribute to a single requirements model.
 
Following a top-down approach, services are functionally composed of sub-services, whereby the lowest level services are sourced from the environment (e.g., third-party COTS, operating system services, and the like). The intermediate services can be sourced from various domains of responsibility. \emph{For example}, a service responsible for processing an insurance claim could be assembled from services providing policy status, claim coverage assessment, and settlement value. Those services may be sourced from different responsibility domains such as policy contracts, policy accounts, valuation, law, or finance.

\paragraph{Service Contract Specification.} The URDAD methodology facilitates the incremental refinement of service requirements across different levels of granularity. Service requirements are encapsulated within a services contract. The specification of service contract includes the identification of stake holders, the functional and quality requirements that they have for a service, and the data structures required for the service's request and result objects. A stake holder may be a role, or another service.

Functional service requirements can be expressed in terms of pre- or post-conditions. If all preconditions of a service are met, the service must be provided. The specification of each pre-condition includes an exception type which must be raised to notify service requesters in case the pre-condition does not hold before the execution of the requested service. A specified post-condition must hold true after the service has been provided. Non-functional service requirements stipulate qualities such as scalability, efficiency, reliability, accessibility, security, etc.

\paragraph{Responsibility Allocation.} During the responsibility allocation step the lower level services that are used to assemble a higher level service are identified by their ability to address the higher level service's functional requirements. Many of URDAD's concepts originate from Responsibility Driven Design (RDD) \cite{wirfs-brock_object-oriented_1989,wirfs-brock_object_2002}. Each service contract and its corresponding service are assigned to a responsibility domain. This prompts domain experts to search within an appropriate responsibility domain for existing services that can be re-used to implement functional requirements.

Service contracts represent requirements on a specific level of granularity. The complete requirements for a service are accrued by the accumulation of its requirements and those of its required lower level services. The hierarchical decomposition of service contracts has made requirements engineering better manageable. Additional levels of granularity can be opened by coalescing several service requirements into a single cohesive super-service. Such abstraction from details (principle of information hiding) reduces the intellectual complexity, improves the understandability of requirements elicitation tasks and opens further reuse opportunities.

\paragraph{Process Design.} Computational processes are specified using services identified in the responsibility 
allocation step. A process specification includes: service requests to address pre- and post-conditions, activities 
to assemble the request objects for these services, activities for handling exceptions raised by lower level 
services, activities for raising exceptions, and the activities of constructing and computational output. Each path through a process graph must either end with an output, or with an exception raise.

