\section{Assessing the URDAD DSL \label{sec:assessment}}

In this section we analyze the URDAD metamodel for unsatisfiable and redundent model elements, compare the complexity of the URDAD and UML metamodels and the URDAD-DSL and UML encoded models, and assess the sufficiency of the URDAD-DSL for code and test generation.

%-------------------------------------------------------------------------------------

\subsection{Metamodel consistency}



We transformed the Ecore metamodel $M1$ to an OWL ontology, $O$, using the TwoUse \cite{parreiras_using_2010} Eclipse plugin in order to use standard reasoning services provided by Description-logic based reasoners. This enabled us to check for (1) \emph{consistency}, i.e\ that there exists a model $M2$ which corresponds to $O$, (2) \emph{satisfiability} which assesses whether there are any concepts in $O$ which cannot be instantiated and which are hence redundent.

In addition one can transform an instance model to an ontology in order to perform the consistency checks above on the model itself and in order to use reasoning services like \emph{classification} and \emph{subsumption}.

%-------------------------------------------------------------------------------------

\subsection{Complexity}

When looking at complexity we are confronted with the complexity of the language used, the conceptual model complexity, the complexity of a model encoded in a particular language, and the complexity of the process to specify the model in a language. The conceptual model complexities is the same irrespecitve of whether the models are encoded in the UML or the URDAD DSL. This is so because we are specifying the same services contracts, processes and data structures. For example, it does not make sense to evaluate the cyclomatic complexity \cite{mccabe_complexity_1976} of an URDAD-DSL encoded process and compare it to the cyclomatic complexity of the same process in a UML encoding.

On the other hand, there are significant differences in the complexity of (a) the actual modeling languages themselves and (b) encoding a model in the respective modeling languages. The complexity of a language can be assessed by assessing the complexity of its metamodel \cite{mohagheghi_evaluating_2007}. The language complexity affects its learnability and the complexity of the tools developed around the language includig model editors, transformation components and validation tools. Even though a more complex language generally entails a steeper learning curve, it need not result in more complex model encodings. Often the converse is true. A more complex language may have more expressive power and thus smaller model sizes. 

The aim of a domain specific language, on the other hand, is to provide a simpler language which introduces only the concepts required for a particular domain, whilst providing the expressive power to effectively make the statements required for that domain, i.e. to be both, a simpler language and to result in more simple models. Being a generic language aiming to please UML. This is evident from the metamodel of UML containing roughly an order of magnitude more classes than the URDAD-DSL metamodel and \todo{count respective relationships} X times more relationships than the URDAD DSL.

As a rough estimate of the relative complexity differences between the instance models we count the number of classes and realtionships which have to be introduced when encoding an instance model using the UML compared to that obtained when using the URDAD-DSL. This has been done against two representative examples. The results are ... \todo{Actually still needs to be done. Note the models must contain the same information content}. 


\todo{Analyze results for causes, e.g. adding semantic links, duplication, ...} Some of the additional artifacts in a UML encoding of an URDAD model include (1) the representation of service as both use case and service in services contract and the required linkage between them, (2) the duplication assignment of a separate service provider contract to a package, (3) \dots

\todo{Discuss the complexity of the language usage. Discuss why it aint good for UML (with references), that it depends on the concrete syntax and tools for URDAD-DSL and that there are still many open questions}

%-------------------------------------------------------------------------------------

\subsection{Sufficiency}

This section assesses the sufficiency of the URDAD-DSL with respect to requirements traceability, implementation mappings and test generation. 

Requirements traceability is important for design validation and estimation. Validation includes assessing sufficiency and neccessity, i.e.\ assessing whether all requirements are met and whether all model elements are required. This has to be done across levels of granularity \cite{dick_design_2005}. Ramesh et al.\ \cite{ramesh_toward_2001} identify four core traceability link types including (i) \emph{satisfaction links} which represent links between requirements and activities which satisfy them, (ii) \emph{evolutional links} which link change requests and the resulting changes, (iii) \emph{rationale links} which link requirements to the rationale (e.g. goals) which drive them and (iv) \emph{dependency links} which represent links between model elements.

In the URDAD metamodel satisfaction links are represented by \verb+usedToAddress+ links between services and pre- and post-conditions. They can be used to trace that all functional requirements are addressed and that one does not use services which do not address functional requirements. Evolutionary links are not addressed within the URDAD metamodel and are left to the version control environment. Higher level purpose, goals and rationale links are also not addressed in URDAD. The metamodel does, however, include the \verb+requiredBy+ linkage between requirements and the stakeholders which require them. A requirement around a service may be required by a responsibility domain (i.e.\ a roles) or by another service. The metamodel enforces that the traceability of a requirement and the responsibility domains/services for which require them is specified. Finally, dependency links are included in the model. The dependency is formost between services and service contracts, i.e.\ a particular process design for a service has dependencies on services contracts (not on particular service implementations). Note that the URDAD metamodel does not differentiate between dependency and satisfaction links. Requirements result in dependencies and if the dependencies are available, the requirements are satisfied.

Code generation in a services oriented approach requires for each service the specification of the process through which this higher level service is assembled from lower level services. This includes the standard process logic around sequential, concurrent and conditional activities, specification of service requests, the maintenance of process state, the construction of the request object and the concepts of returning a result or raising an exception. In URDAD service requests are enforced to be made against services contracts, i.e. URDAD enforces decoupling between service providers. In this context URDAD assumes that the concrete service providers used to realize the services contracts are either injected by the run-time environment like in Spring or Java-EE based dependency injection, or are determined during the implementation mapping phase.

The services contract specification within the URDAD-DSL contains the specification of service inputs and outputs, pre- and post-conditions and quality requirements. A pre-condition for a service is the requirement that a condition holds. If the pre-condition does not hold true, the service provider is entitled to refuse the service. A post-condition is a condition which must hold true after the service has been provided. The same condition may be a pre-condition for several services as well as a post condition for other services. For example, the condition \emph{studentIsRegistered} can be for the \verb+enrollStudentForCoursePresentation+ service as well as the post-condition for the \verb+registerStudent+ service. 

In order for conditions to be reusable across several pre- and post-conditions, a condition needs to receive information. For example the \emph{studentIsRegistered} condition needs to receive the information about the student we are referring to. In addition conditions need to be specified with respect to the result object and information obtained from the environment. In a services oriented approach, environmental information is obtained through other services. For example, the \emph{studentIsRegistered} condition could be assessed by using services like \verb+isRegistered+ or \verb+provideRegistrationDetails+. The URDAD-DSL supports conditions with inputs specified in the pre and post-concitions of services and which are us, for functional testability one needs to specify a process assembled across services through which information from the environment is retrieved together with a set of state constraints applied across the obtained data objects containing the environmental information\footnote{Note that the test specification is not based on the design of a particular process (e.g. state chart), but independent of service realizations within a process independent services contract.}. Also in testability the decoupling of the test process from actual service implementations is enforced by requiring that the service requests tie into services contracts, not service implementations. 

The one aspect which is currently not at all addressed in URDAD is the concept of event processing.
 

