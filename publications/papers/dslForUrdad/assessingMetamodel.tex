\section{Assessing the URDAD DSL \label{sec:assessment}}

In this section we analyze the URDAD metamodel for unsatisfiable and redundent model elements, compare the complexity of the URDAD and UML metamodels and the URDAD-DSL and UML encoded models, and assess the sufficiency of the URDAD-DSL for code and test generation.

%-------------------------------------------------------------------------------------

\subsection{Metamodel consistency}

The URDAD Ecore metamodel describes and relates the concepts of the URDAD domain of discourse. Similarly, Description Logics (DL) are a family of knowledge representation languages that can be used to represent the knowledge of an application domain in a structured and formally well-understood way by first defining the relevant concepts of the domain, and then using these concepts to specify properties of objects and individuals occurring in the domain. The general terminology is contained in the TBox. The contingent knowledge about particular individuals is contained in the ABox. The fundamental inference on concept expressions is \emph{subsumption}. A special case of subsumption with the subsumer being the empty concept is \emph{satisfiability}, which is the problem of checking whether a concept description does not necessarily denote the empty concept. For empty concepts the set of individuals of this concept is always empty. We transformed the URDAD Ecore $\mathcal{M}1$ metamodel into an $\mathcal{ALC}(\textbf{D})$ ontology using the TwoUse \cite{parreiras_using_2010} Eclipse plugin. The collection of modeling concepts defined by the URDAD metamodel was successfully validated to be satisfiable.

URDAD $\mathcal{M}0$ instance models are transformed into ontological instance knowledge based on the $\mathcal{ALC}(\textbf{D})$ representation of the URDAD metamodel. The $\mathcal{M}0$ assertional knowledge and the terminological axioms representing the $\mathcal{M}1$ model are automatically checked by a Description Logics reasoner to be non-contradictory. In particular, qualified cardinality restrictions are used to check minimum-cardinality constraints defined for URDAD modeling constructs (the unique name assumption is enforced for ontological individuals to prevent the reasoner from inferring their identity). For example, ...\todo{provide example}

%-------------------------------------------------------------------------------------

\subsection{Complexity}

When looking at complexity we are confronted with (1) the complexity of the language used, (2) the conceptual model complexity, (3) the complexity of a model encoded in a particular language, and (4) the complexity of the process to specify the model in the language. The conceptual model complexity is the same irrespective of whether the models are encoded in the UML or the URDAD DSL. This is so because we are specifying the same model, i.e.\ the same services contracts, processes and data structures. For exxample, it is senseless to evaluate the cyclomatic complexity \cite{mccabe_complexity_1976} of an URDAD-DSL encoded process and compare it to the cyclomatic complexity of the same process in a UML encoding.

The complexity of a language can be assessed by assessing the complexity of its metamodel \cite{mohagheghi_evaluating_2007}. The language complexity affects its learnability and the complexity of the tools developed around the language including model editors, transformation components and validation tools. Even though a more complex language generally entails a steeper learning curve, it need not result in more complex model encodings. Often the converse is true. A more complex language may have more expressive power and thus smaller model sizes. 

The aim of a domain specific language, on the other hand, is to provide a simpler language which introduces only the concepts required for a particular domain, whilst providing the expressive power to effectively make the statements required for that domain, i.e. to be both, a simpler language and to result in more simple models. Being a generic language aiming to please a range of different user communities using different approaches to analysis and design. This is evident from the metamodel of UML containing about 16 times as many classes and 7 times more relationships than the URDAD DSL.

As a rough estimate of the relative complexity differences between the instance models we count the number of classes and relationships which have to be introduced when encoding an instance model using the UML compared to that obtained when using the URDAD-DSL. This has been done against two representative examples. The results are ... \todo{Actually still needs to be done. Note the models must contain the same information content}. 


\emph{Analyze results for causes, e.g. adding semantic links, duplication, ...} Some of the additional artifacts in a UML encoding of an URDAD model include (1) the representation of service as both use case and service in services contract and the required linkage between them, (2) the duplication assignment of a separate service provider contract to a package, (3) \dots

\emph{Discuss the complexity of the language usage. Discuss why UML is complex to use (with references) and why the complexity is even higher when using UML in the context of MDE. Also discuss that it depends on the concrete syntax and tools for URDAD-DSL and that there are still many open questions}

%-------------------------------------------------------------------------------------

\subsection{Sufficiency}

This section assesses the sufficiency of the URDAD-DSL with respect to requirements traceability, test generation and implementation mappings. 

Requirements traceability is important for design validation and estimation. Validation includes assessing sufficiency and neccessity, i.e.\ assessing whether all requirements are met and whether all model elements are required. This has to be done across levels of granularity \cite{dick_design_2005}. Ramesh et al.\ \cite{ramesh_toward_2001} identify four core traceability link types including (i) \emph{satisfaction links} which represent links between requirements and activities which satisfy them, (ii) \emph{evolutional links} which link change requests and the resulting changes, (iii) \emph{rationale links} which link requirements to the rationale (e.g. goals) which drive them and (iv) \emph{dependency links} which represent links between model elements.

In the URDAD metamodel satisfaction links are represented by \verb+usedToAddress+ links between services and functional requirements. They can be used to trace that all functional requirements are addressed and that one does not use services which do not address functional requirements. Evolutionary links are not addressed within the URDAD metamodel and are left to the version control environment. Higher level purpose, goals and rationale links are also not addressed in URDAD. The metamodel does, however, include the \verb+requiredBy+ linkage between requirements and the stakeholders which require them. A requirement around a service may be required by a responsibility domain (i.e.\ a roles) or by another service. Finally, dependency links are intrinsically in the model including  dependency of services on the services contracts of lower level services they require and dependency between data structure elements. 

The metamodel was found to be sufficient to generate or specify a concrete text grammar capturing the concepts required by the URDAD methodology. Using EMFText \cite{heidenreich_derivation_2009}, we generated a language-aware editor supporting syntax checking and high-lighting.

Sufficient service contract specification needs to support the generation of functional testing which, in turn, requires constraints which can be validated. The following listing uses the concrete text syntax developed for the URDAD-DSL to specify the pre- and post-conditions of the \verb+enrollForPresentation+ service together with the specification of the data structures for the request and result object:
\tiny \begin{lstlisting}[numbers=left,escapechar=|]
ServiceContract enrollForPresentation
{
   FunctionalRequirements receiving Variable enrollForPresentationRequest 
      ofType EnrollForPresentationRequest
   {
      PreCondition enrollmentPrerequisitesMet
         requiredBy (TrainingRegulator Student) 
         raises EnrollmentPrerequisitesNotSatisfiedException
         checks constraint enrollmentPrerequisitesForPresentationMet
         with ValueOf enrollForPresentationRequest
      PostCondition enrollmentProcessPerformed
         requiredBy (Student Client TrainingRegulator)
         ensures constraint studentEnrolledForPresentation 
         with ValueOf studentEnrolledRequest constructedUsing doSequential
         {
            create Variable studentEnrolledRequest ofType StudentEnrolledRequest
            set Query OCL:"studentEnrolledRequest.personIdentifier" equalTo
                Query OCL:"enrollForPresentationRequest.personIdentifier"                            
            set Query OCL:"studentEnrolledRequest.presentationIdentifier" equalTo
                Query OCL:"enrollForPresentationRequest.presentationIdentifier"                            
         }  
      PostCondition invoiceIssued ...
    }            
    Request DataStructure EnrollForPresentationRequest 
    {
       has identification presentationIdentifier identifying Presentation
       has identification studentIdentifier identifying Person
       has component clientIdentifier ofType LegalEntity         
    }
    Result DataStructure EnrollForPresentationResult 
    {
       has component proofOfEnrollment ofType ProofOfEnrollment
       has component invoice ofType Invoice
       has component studyGuide ofType StudyGuide
    }
}
\end{lstlisting}\normalsize

The pre- and post-conditions refer to reusable constraints. Being in a services oriented approach, constraints are specified as a combination of a process which extracts information form the environment and a set of data structure constraints applied against the obtained information.
\tiny \begin{lstlisting}[numbers=left,escapechar=|]
StateConstraint studentEnrolledForPresentation 
   receiving Variable enrollForPresentationRequest ofType EnrollForPresentationRequest
{
   stateAssessmentProcess doSequential
   {
      create Variable getEnrollmentsRequest ofType GetEnrollmentsRequest
      set Query OCL:"getEnrollmentsRequest.presentationIdentifier" equalTo
          Query OCL:"enrollForPresentationRequest.presentationIdentifier"
      requestService getEnrollments with getEnrollmentsRequest yielding
          Variable getEnrollmentsResult ofType GetEnrollmentsResult
   }
   Constraint OCL:"getEnrollmentsResult.enrollments.includes(enrollForPresentationRequest.personIdentifier)"
}
\end{lstlisting}\normalsize
The above specification is sufficient for generating the functional tests for the service contract. These are independent of the process specification of a concrete service realizing the services contract.

Code generation in a services oriented approach requires for each service the specification of the process through which this higher level service is assembled from lower level services. This includes the standard process logic around sequential, concurrent and conditional activities, specification of service requests, the maintenance of process state, the construction of the request object and the concepts of returning a result or raising an exception. The process is orchestrated across the services used to realize the pre- and post-conditions:
\tiny \begin{lstlisting}[numbers=left,escapechar=|]
Service enrollForPresentationImpl realizes enrollForPresentation 
   receiving Variable enrollForPresentationRequest ofType EnrollForPresentationRequest
{
   use checkStudentSatisfiesEnrollmentPrerequisites toAddress (enrollmentPrerequisitesMet)
   use issueInvoice toAddress (financialPrerequisitesSatisfied invoiceIssued) 
   use performEnrollment toAddress (invoiceIssued)
   
   doSequential
   {
      create Variable checkStudentSatisfiesEnrollmentPrerequisitesRequest 
         ofType CheckStudentSatisfiesEnrollmentPrerequisitesRequest               
      set Query OCL:"enrollForPresentationRequest.studentIdentifier" equalTo 
          Query OCL:"checkEnrollmentPrerequisitesRequest.studentIdentifier"
      set Query OCL:"enrollForPresentationRequest.presentationIdentifier" equalTo
          Query OCL:"checkEnrollmentPrerequisitesRequest.presentationIdentifier"
                     
      requestService checkStudentSatisfiesEnrollmentPrerequisites 
          with checkStudentSatisfiesEnrollmentPrerequisitesRequest 
          yielding Variable checkStudentSatisfiesEnrollmentPrerequisitesResult
              ofType CheckStudentSatisfiesEnrollmentPrerequisitesResult
      choice
      {
          if Constraint enrollmentMeetsPrerequisitesMet 
                OCL:"checkStudentSatisfiesEnrollmentPrerequisitesResult.enrollmentPrerequisitesMet = true"
             doSequential
             {
                ...
                requestService issueInvoice with issueInvoiceRequest 
                   yielding Variable issueInvoiceResult ofType IssueInvoiceResult
                {
                   on FinancialPrerequisitesNotSatisfiedException 
                        raiseException FinancialPrerequisitesNotSatisfiedException
                }
				...
                requestService performEnrollment with enrollRequest 
                   yielding Variable performEnrollmentResult ofType PerformEnrollmentResult
                create Variable enrollForPresentationResult ofType EnrollForPresentationResult
                   set Query OCL:"issueInvoiceResult.invoice" equalTo
                       Query OCL:"enrollForPresentationResult.invoice"
     				...                       
                   returnResult  enrollForPresentationResult
               }
               else raiseException EnrollmentPrerequisitesNotSatisfiedException
            }
      }
   }         
}           
\end{lstlisting}\normalsize
Note that the URDAD methodology enforces decoupling through services contracts and that this is also enforced in the URDAD metamodel. In this context URDAD assumes that the concrete service providers used to realize the services contracts are either injected by the run-time environment like in Spring or Java-EE based dependency injection, or are determined during the implementation mapping phase.

\todo{Discuss various validation steps for instance models including DL based, parser, validation against metamodel and OCL constraints, ...}

