\section{Assessing the URDAD DSL \label{sec:assessment}}

In this section we analyze the URDAD metamodel for unsatisfiable and redundent model elements, compare the complexity of the URDAD and UML metamodels and the URDAD-DSL and UML encoded models, and assess the sufficiency of the URDAD-DSL for code and test generation.

%-------------------------------------------------------------------------------------

\subsection{Metamodel consistency}

We transformed the Ecore metamodel $\mathcal{M}1$ to an OWL ontology, $\mathcal{O}$, using the TwoUse \cite{parreiras_using_2010} Eclipse plugin in order to use standard reasoning services provided by Description-logic based reasoners. This enabled us to check for (1) \emph{consistency}, i.e\ that there exists a model $\mathcal{O}$ which corresponds to $\mathcal{O}$, (2) \emph{satisfiability} which assesses whether there are any concepts in $\mathcal{O}$ which cannot be instantiated and which are hence redundant.

In addition one can transform an instance model to an ontology in order to perform the consistency checks above on the model itself and in order to use reasoning services like \emph{classification} and \emph{subsumption}.

%-------------------------------------------------------------------------------------

\subsection{Complexity}

When looking at complexity we are confronted with (1) the complexity of the language used, (2) the conceptual model complexity, (3) the complexity of a model encoded in a particular language, and (4) the complexity of the process to specify the model in the language. The conceptual model complexity is the same irrespective of whether the models are encoded in the UML or the URDAD DSL. This is so because we are specifying the same model, i.e.\ the same services contracts, processes and data structures. For exxample, it is senseless to evaluate the cyclomatic complexity \cite{mccabe_complexity_1976} of an URDAD-DSL encoded process and compare it to the cyclomatic complexity of the same process in a UML encoding.

The complexity of a language can be assessed by assessing the complexity of its metamodel \cite{mohagheghi_evaluating_2007}. The language complexity affects its learnability and the complexity of the tools developed around the language including model editors, transformation components and validation tools. Even though a more complex language generally entails a steeper learning curve, it need not result in more complex model encodings. Often the converse is true. A more complex language may have more expressive power and thus smaller model sizes. 

The aim of a domain specific language, on the other hand, is to provide a simpler language which introduces only the concepts required for a particular domain, whilst providing the expressive power to effectively make the statements required for that domain, i.e. to be both, a simpler language and to result in more simple models. Being a generic language aiming to please a range of different user communities using different approaches to analysis and design. This is evident from the metamodel of UML containing about 16 times as many classes and 7 times more relationships than the URDAD DSL.

As a rough estimate of the relative complexity differences between the instance models we count the number of classes and relationships which have to be introduced when encoding an instance model using the UML compared to that obtained when using the URDAD-DSL. This has been done against two representative examples. The results are ... \todo{Actually still needs to be done. Note the models must contain the same information content}. 


\emph{Analyze results for causes, e.g. adding semantic links, duplication, ...} Some of the additional artifacts in a UML encoding of an URDAD model include (1) the representation of service as both use case and service in services contract and the required linkage between them, (2) the duplication assignment of a separate service provider contract to a package, (3) \dots

\emph{Discuss the complexity of the language usage. Discuss why UML is complex to use (with references) and why the complexity is even higher when using UML in the context of MDE. Also discuss that it depends on the concrete syntax and tools for URDAD-DSL and that there are still many open questions}

%-------------------------------------------------------------------------------------

\subsection{Sufficiency}

This section assesses the sufficiency of the URDAD-DSL with respect to requirements traceability, implementation mappings and test generation. 

Requirements traceability is important for design validation and estimation. Validation includes assessing sufficiency and neccessity, i.e.\ assessing whether all requirements are met and whether all model elements are required. This has to be done across levels of granularity \cite{dick_design_2005}. Ramesh et al.\ \cite{ramesh_toward_2001} identify four core traceability link types including (i) \emph{satisfaction links} which represent links between requirements and activities which satisfy them, (ii) \emph{evolutional links} which link change requests and the resulting changes, (iii) \emph{rationale links} which link requirements to the rationale (e.g. goals) which drive them and (iv) \emph{dependency links} which represent links between model elements.

In the URDAD metamodel satisfaction links are represented by \verb+usedToAddress+ links between services and functional requirements. They can be used to trace that all functional requirements are addressed and that one does not use services which do not address functional requirements. Evolutionary links are not addressed within the URDAD metamodel and are left to the version control environment. Higher level purpose, goals and rationale links are also not addressed in URDAD. The metamodel does, however, include the \verb+requiredBy+ linkage between requirements and the stakeholders which require them. A requirement around a service may be required by a responsibility domain (i.e.\ a roles) or by another service. Finally, dependency links are intrinsically in the model including  dependency of services on the services contracts of lower level services they require and dependency between data structure elements. 


Code generation in a services oriented approach requires for each service the specification of the process through which this higher level service is assembled from lower level services. This includes the standard process logic around sequential, concurrent and conditional activities, specification of service requests, the maintenance of process state, the construction of the request object and the concepts of returning a result or raising an exception. Note that the URDAD methodology enforces decoupling through services contracts and that this is also enforced in the URDAD metamodel. In this context URDAD assumes that the concrete service providers used to realize the services contracts are either injected by the run-time environment like in Spring or Java-EE based dependency injection, or are determined during the implementation mapping phase.


The services contract specification within the URDAD-DSL contains the specification of service inputs and outputs, pre- and post-conditions and quality requirements. A pre-condition for a service is the requirement that a condition holds. If the pre-condition does not hold true, the service provider is entitled to refuse the service. A post-condition is a condition which must hold true after the service has been provided. The same condition may be a pre-condition for several services as well as a post condition for other services. For example, the condition \emph{studentIsRegistered} can be for the \verb+enrollStudentForCoursePresentation+ service as well as the post-condition for the \verb+registerStudent+ service. 

In order for conditions to be reusable across several pre- and post-conditions, a condition needs to receive information. For example the \emph{studentIsRegistered} condition needs to receive the information about the student we are referring to. In addition conditions need to be specified with respect to the result object and information obtained from the environment. In a services oriented approach, environmental information is obtained through other services. For example, the \emph{studentIsRegistered} condition could be assessed by using services like \verb+isRegistered+ or \verb+provideRegistrationDetails+. The URDAD-DSL supports conditions with inputs specified in the pre and post-concitions of services and which are us, for functional testability one needs to specify a process assembled across services through which information from the environment is retrieved together with a set of state constraints applied across the obtained data objects containing the environmental information\footnote{Note that the test specification is not based on the design of a particular process (e.g. state chart), but independent of service realizations within a process independent services contract.}. Also in testability the decoupling of the test process from actual service implementations is enforced by requiring that the service requests tie into services contracts, not service implementations. 

The one aspect which is currently not at all addressed in URDAD is the concept of event processing.
 

