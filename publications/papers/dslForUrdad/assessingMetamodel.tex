\section{Discussion of the URDAD DSL \label{sec:assessment}}

In this section we analyse our meta model's consistency, assess the sufficiency of the URDAD DSL for traceability, code and test generation, and compare the complexities of URDAD DSL and URDAD UML based approaches.

\subsection{Consistency}
The URDAD meta model describes and relates the concepts of the URDAD domain of discourse. Similarly, \emph{Description Logics} (DL) are a family of knowledge representation languages that can be used to represent the knowledge of an application domain in a well-structured and formally sound manner. In DL, the general terminology of a domain is contained in the TBox. The contingent knowledge about particular individuals is contained in the ABox. In DL, the fundamental inference relation on concept expressions is the \emph{subsumption} relation. A special case of subsumption is \emph{satisfiability} which poses the problem of checking whether a concept description does not necessarily denote the empty concept. For empty concepts 
the set of individuals of this concept is always empty. We have transformed our URDAD meta model $\mathcal{M}1$ into an $\mathcal{ALC}(\textbf{D})$ ontology using the \emph{TwoUse} \cite{parreiras_using_2010} Eclipse plugin. The collection of modelling concepts defined by the URDAD meta model was successfully validated to be \emph{satisfiable} $\surd$.

URDAD $\mathcal{M}0$ instance models were transformed into ontological instance knowledge based on the $\mathcal{ALC}(\textbf{D})$ representation of the URDAD meta model. The $\mathcal{M}0$ assertional knowledge and the terminological axioms representing the $\mathcal{M}1$ model were automatically checked by a 
Description Logics reasoner to be \emph{non-contradictory} $\surd$. In particular, qualified cardinality restrictions were used to check minimum-cardinality constraints defined for URDAD modelling constructs like that a requirement is required by one or more stakeholders (the unique name assumption is enforced for ontological individuals to prevent the reasoner from inferring their identity). 

\subsection{Sufficiency for MDE}
Requirements traceability is important for design validation and estimation. Validation includes assessing sufficiency and necessity, i.e., assessing whether all requirements are met and whether all model elements are required. This has to be done across levels of granularity \cite{dick_design_2005},whereby four types of traceability should be taken into account \cite{ramesh_toward_2001}: \emph{satisfaction} links, \emph{evolutional} links, \emph{rationale} links, and \emph{dependency} links between model elements.

In our meta model, satisfaction links are represented by \verb+usedToAddress+ links between services and functional requirements. They can be used to trace that all functional requirements are addressed and that one does not use services which do not address functional requirements. Evolutionary links are not addressed within the URDAD meta model as they are provided by the version control environment. Rationale links are currently also not represented in URDAD. The meta model does, however, include  \verb+requiredBy+ links between requirements and their stakeholders. Dependencies between model elements are explicitly represented. 

The meta model was found to be sufficient to generate or specify a concrete textual grammar capturing the concepts required by the URDAD methodology. The generated editor and parser as well as the standard model validators provide basic validation against the meta model, including compliance to the meta model constraints. We populated an example model and encoded it in both, the URDAD DSL using out textual syntax, and in UML.

Indeed, a requirements model specified in the URDAD DSL can be mapped onto a process specified in URDAD UML (a requires the mapping of functional requirements onto functional test processes). The map-ability from our DSL into UML should facilitate further tool-support and, later, industrial adoption of the DSL.

The model has been analyzed by developers and was found to be sufficient for implementation mapping (code generation) and test generation.

The concept of `event' is not reflected in URDAD's meta model. However, events do not fit naturally into a service-oriented approach where services are regarded as stateless. Even though events can be `simulated' by mapping them onto onto either the receipt of a service request or a response, URDAD and its meta model are not particularly suited to modelling event-centric systems.

\subsection{Complexity}
The term `complexity' is here understood intuitively as `difficulty of application' from an practical perspective. When looking at a modelling task, we are confronted with the complexity of the model under construction, the complexity of the language used to this end, and the complexity of the workflow through which the task can be accomplished.

The \emph{conceptual model complexity} is the same, irrespective  of whether the models are denoted in the UML or the URDAD DSL. This is so because we are specifying in both cases the same information about a system under construction.

The \emph{complexity of a language} can be assessed by assessing the complexity of its meta model \cite{mohagheghi_evaluating_2007}. The language complexity affects its learnability and the complexity  of the tools developed around the language including model editors, transformation components and validation tools. Even though a more complex language generally entails a steeper learning curve, it need not result in more complex model encodings. Often the converse is true. A more complex language may have more expressive power and can thus yield smaller model sizes. 

The aim of a domain specific language, on the other hand, is to provide a simpler language which introduces only the concepts required for a particular domain, whilst providing the expressive power to effectively make the statements required for that domain, i.e. to be both, a simpler language and to result in more simple models.

In the case of our meta model, its UML representation contains about 16 times as many classes and 7 times more relationships than its equivalent in URDAD DSL. Comparing the URDAD UML model for our example to an equivalent URDAD DSL model we find that the URDAD DSL model has notably lower complexity. Moreover, the URDAD DSL can elegantly describe additional model constructs, which cannot elegantly be represented in URDAD-UML.

The \emph{model complexity} \todo{re-insert model sufficiency paragraph}

The \emph{usage complexity}  However, requirements specialists need to ensure that they use only a very limited subset which provides the required semantics. For example, when using activity diagrams they cannot use `swim lanes' because UML does not have the concept of an activity realizing a service. Instead one needs to define an activity diagram using only call operations which are linked to interfaces representing service contracts together with flow logic.
\todo{Fritz:Discuss the complexity of the language usage. Discuss why UML is complex to use (with references) and why the complexity is even higher when using UML in the context of MDE. Also discuss that it depends on the concrete syntax and tools for URDAD DSL and that there are still many open questions}
