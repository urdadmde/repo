\section{Assessing the URDAD DSL \label{sec:assessment}}

In this section we analyze the URDAD metamodel for unsatisfiable and redundent model elements, compare the complexity of the URDAD and UML metamodels and the URDAD-DSL and UML encoded models, and assess the sufficiency of the URDAD-DSL for code and test generation.

%-------------------------------------------------------------------------------------

\subsection{Core metamodel integrity assessment}

\emph{Alex's section}


\begin{itemize}
  \item Check that no classes unsatisfiable
  \item Redundency checks (redundent classes, redundent attributes and properties) redundend constraints
  \item Check consistency of OCL constraints
\end{itemize}

%-------------------------------------------------------------------------------------

\subsection{Complexity}

The complexities of instance models will be the same irrespecitve of whether the models are encoded in the UML or the URDAD DSL. This is so because we are specifying the same services contracts, processes and data structures. For example, it does not make sense to evaluate the cyclomatic complexity of an URDAD-DSL encoded process and compare it to the cyclomatic complexity of the same process in a UML encoding.

On the other hand, there are significant differences in the complexity of (a) the actual modeling languages themselves and (b) encoding a model in the respective modeling languages. The complexity of the languages themselves can be assessed by assessing the complexity of their respective metamodels \cite{mohagheghi_evaluating_2007}. A more complex language generally entails a steeper learning curve, but need not necessarily result in more complex model encodings. Often the converse is true. A more complex language may have more expressive power and thus smaller model sizes. 

However, the aim of a domain specific language is usually to be both, provide a simpler language which introduces only the concepts required for a particular domain, and to provide the expressive power to effectively make the statemets required for that domain, i.e. to be both, a simpler language and to result in more simple models. Being a generic language aiming to please UML. This is evident from the metamodel of UML containing roughly an order of magnitude more classes than the URDAD-DSL metamodel.

Also complexity to extract information from model.

"An essential
requirement of a meta-modeling language is therefore
its ability to concisely capture all aspects of a modeling
language, including its syntax and semantics [2]. Rossi
et al. write that that there exists an intrinsic
dependency between the metamodel and the
learnability of a language since a language?s metamodel
serves as an indication of its functional
complexity [12]. A metamodel?s conceptual
complexity should lead to greater expressive power,
and thus smaller models in size. For example,
modeling languages developed for a specific domain
have more expressive power and are closer to the
experts? knowledge of the domain than generalpurpose
modeling languages, but may be more
complex to learn for a novice.
Rossi et al. therefore propose measuring the
complexity of a modeling language by looking at its
meta-model. A modeling language is viewed as a set of
techniques such as class diagrams and state machine
diagrams. For each technique, metrics of the count of
object types, relationships and property types in the
metamodel are calculated. The conceptual complexity
of a technique is a sum vector of the above metrics,
and the complexity of a modeling language is a sum
vector of complexity of all its techniques. The
techniques are assumed not to be interrelated. Rossi et
al. have compared several OO methods using the above
metrics and concluded that OO methods get more
complex with time. Another evaluation done by Siau
and Cao (presented in [5]) based on the above metrics
concluded that UML is 2 to 11 times more complex
than other OO methods.
As an example, we can mention that the OMG
Systems Modeling Language (OMG SysMLTM) defines
correctness, precision, conciseness, consistency and
understandability as its quality goals [9], without
further discussion on what these terms mean and how
they are achieved.``


Both structural and functional complexity - lang only structural


Language complexity and encoded model complexity. The UML metamodel is orders of magnitude larger than the URDAD metamodel. 


Structural complexity

For process complexity one generally usess the Mcabe or cyclometic complexity measure \cite{mccabe_complexity_1976}.

Additional artifacts required by an UML encoding of an URDAD model
\begin{itemize}
  \item Representation of service as both use case and service in services contract
  \item Realization link linking service and use case
  \item Package and interface duplication, each package representing a responsibility domain and defining an services contract (interface) for the responsibility domain.
  \item
\end{itemize}


%-------------------------------------------------------------------------------------

\subsection{Sufficiency}

This section assesses the sufficiency of the URDAD-DSL with respect to requirements traceability, implementation mappings and test generation. 

Requirements traceability is important for design validation and estimation. Validation includes assessing sufficiency and neccessity, i.e.\ assessing whether all requirements are met and whether all model elements are required. This has to be done across levels of granularity \cite{dick_design_2005}. Ramesh et al.\ \cite{ramesh_toward_2001} identify four core traceability link types including (i) \emph{satisfaction links} which represent links between requirements and activities which satisfy them, (ii) \emph{evolutional links} which link change requests and the resulting changes, (iii) \emph{rationale links} which link requirements to the rationale (e.g. goals) which drive them and (iv) \emph{dependency links} which represent links between model elements.

In the URDAD metamodel satisfaction links are represented by \verb+usedToAddress+ links between services and pre- and post-conditions. Evolutionary links are not addressed within the URDAD metamodel and are left to the version control environment. Higher level purpose, goals and rationale links are also not addressed in URDAD. The metamodel does, however, include the \verb+requiredBy+ linkage between requirements and the stakeholders which require them. A requirement around a service may be required by a responsibility domain (i.e.\ a roles) or by another service. The metamodel enforces that the traceability of a requirement and the responsibility domains/services for which require them is specified. Finally, dependency links are included in the model. The dependency is formost between services and service contracts, i.e.\ a particular process design for a service has dependencies on services contracts (not on particular service implementations). Note that the URDAD metamodel does not differentiate between dependency and satisfaction links. Requirements result in dependencies and if the dependencies are available, the requirements are satisfied.

Code generation in a services oriented approach requires for each service the specification of the process through which this higher level service is assembled from lower level services. This includes the standard process logic around sequential, concurrent and conditional activities, specification of service requests, the maintenance of process state, the construction of the request object and the concepts of returning a result or raising an exception. In URDAD service requests are enforced to be made against services contracts, i.e. URDAD enforces decoupling between service providers. In this context URDAD assumes that the concrete service providers used to realize the services contracts are either injected by the run-time environment like in Spring or Java-EE based dependency injection, or are determined during the implementation mapping phase.

The services contract specification within the URDAD-DSL contains the specification of service inputs and outputs, pre- and post-conditions and quality requirements. A pre-condition for a service is the requirement that a condition holds. If the pre-condition does not hold true, the service provider is entitled to refuse the service. A post-condition is a condition which must hold true after the service has been provided. The same condition may be a pre-condition for several services as well as a post condition for other services. For example, the condition \emph{studentIsRegistered} can be for the \verb+enrollStudentForCoursePresentation+ service as well as the post-condition for the \verb+registerStudent+ service. 

In order for conditions to be reusable across several pre- and post-conditions, a condition needs to receive information. For example the \emph{studentIsRegistered} condition needs to receive the information about the student we are referring to. In addition conditions need to be specified with respect to the result object and information obtained from the environment. In a services oriented approach, environmental information is obtained through other services. For example, the \emph{studentIsRegistered} condition could be assessed by using services like \verb+isRegistered+ or \verb+provideRegistrationDetails+. The URDAD-DSL supports conditions with inputs specified in the pre and post-concitions of services and which are us, for functional testability one needs to specify a process assembled across services through which information from the environment is retrieved together with a set of state constraints applied across the obtained data objects containing the environmental information\footnote{Note that the test specification is not based on the design of a particular process (e.g. state chart), but independent of service realizations within a process independent services contract.}. Also in testability the decoupling of the test process from actual service implementations is enforced by requiring that the service requests tie into services contracts, not service implementations. 
 

%-------------------------------------------------------------------------------------

\subsection{Language semantics}



%-------------------------------------------------------------------------------------

\subsection{Assessing model qualities}



\begin{itemize}
  \item Completeness checks
(What does completeness mean - That only technical information needs to be provided and that the full requirements
from a business perspective are specified across levels of granularity.)
    \begin{itemize}
     \item all OCL constraints for decision conditions specified
     \item all OCL constraints for pre and post-conditions specified
     \item All required request and result fields all specified either via OCL constraints 
	or by default values.
    \end{itemize}
  \item Check that process addresses all functional requirements and nothing but the functional requirements.
\end{itemize}

