\section{Introduction}

Poor requirements quality is still the main cause of system errors \cite{heck_experiences_2008,_strategies_2011}. There are a number of factors that contribute to defects in requirements specifications. Requirements are subject to intrinsic uncertainty and misinterpretation if specification techniques with only informal or vaguely defined requirements semantics \cite{ferguson_empirical_2006} are used. Specifying requirements only at a single or insufficient level of granularity and abstraction leaves developers to make presumptions about lower level requirements \cite{espana_evaluating_2009, getBetterReference}. Also, there is only very limited support for the validation of requirements for consistency and completeness. Moreover, support for the automatic extraction of executable test cases from requirements specifications is spotty \cite{bashardoust-tajali_extracting_2008}.

Model-Driven Engineering (MDE) \cite{schmidt_model_2006} aims to address some of these issues by 1) using modeling languages with well defined semantics, 2) by requiring primary models to be domain models and not technical models \cite{asnina_computation_2010}, and 3) by providing tool support for MDE processes. As a result, technology-neutral domain models are developed by requirements specialists and not by technical experts \cite{asnina_computation_2010}. In the case of enterprise system development, requirements specialists are represented by business analysts.

URDAD, the {\em Use-Case, Responsibility-Driven Analysis and Design} \cite{fritz_solms_technology_2007} methodology supports the MDE approach \cite{solms_urdad_2010}. It is used by requirements specialists (i.e.\ business analysts) to develop and validate technology neutral requirements models. URDAD models are {\em Platform Independent Models} (PIM) in the {\em Model Driven Architecture} (MDA) \cite{solms_urdad_2010}.

URDAD is a semi-formal services-oriented requirements analysis and tech\-no\-logy-neutral process design methodology. It follows a divide-and-conquer approach by recursively decomposing requirements for a service into a tree of lower level service requirements. Processes from lower level services realize higher level service contracts. Thus, instead of having service requirements at a single level of granularity with complex pre- and post-conditions, the requirements are made more manageable since lower level services have their own pre- and post conditions and their own process specifications linking them to the requirements at yet the next lower level of granularity

The URDAD methodology is independent of the technology used to encode the modeling constructs of an URDAD model. There are several OMG/MDA standards-based options for encoding URDAD models.

Traditionally, requirements specialists used a generic modeling language such as the Unified Model Language (UML) to encode URDAD models. UML is a natural choice due to its wide adoption in industry and its comprehensive tool support. URDAD modeling constructs and constraints are provided through an URDAD UML profile and user discipline. In this approach, however, the burden to only use the URDAD subset of UML and to obey URDAD model semantics is put on the domain experts. Also, a complete URDAD UML profile contains a plethora of OCL constraints, which constrain resultant domain models to valid URDAD models. The bulk and complexity of these constraints impose significant modeling challenges. Modeling complexity and incomplete constraint annotations resulted in high costs and high model defect densities of URDAD domain models \cite{}. In practice, even the aim of developing an URDAD model with model integrity was abandoned in favor of supplying a sufficient requirements model for manual processing by developers.\todo{AP: Meaning of last sentence?}

In this paper, we will present a domain-specific language (DSL) for the domain of technology-neutral, services-oriented requirements modeling. The URDAD DSL is based on a MOF/EMOF metamodel, which is amenable to the comprehensive MDA tool suite for model-to-model and model-to-text transformations and the specification and generation of concrete textual and diagrammatic syntaxes and tools supporting these \cite{gronback_model_2008}. We will analyze the modeling constructs required by URDAD, elucidate and critically assess the URDAD metamodel and propose a concrete textual syntax for an URDAD DSL. A Description Logics (DL) based representation of the URDAD metamodel will be derived from the MOF/EMOF metamodel in order to show its consistency and satisfiability.

The URDAD DSL has two main advantages compared to the use of an URDAD UML profile. Firstly, the resultant language is a fraction of the size of UML and introduces exactly the modeling constructs required by URDAD. This results in considerably lower model complexity and, with the appropriate tools at hand, simplifies the process through which requirements specialists construct requirements models. Secondly, since exactly the required modeling constructs are introduced, one only needs to specify a much smaller set of  meta-model constraints for the validation of instance models -- both for conformance to an URDAD model as well as for completeness and consistency.

The paper is structured as follows. Our approach is put into context with related work in Section \ref{sec:relatedWork}. In Section \ref{sec:urdadMethodology}, we give a compact overview of the URDAD methodology. Section \ref{sec:metamodel} introduces the URDAD metamodel, its core concepts and the rationale behind it. A concrete textual syntax for the URDAD DSL is presented and exemplified in Section \ref{}. Section \ref{sec:tools} describes the implementation of the URDAD DSL tool suite. In Section \ref{sec:metamodelAssessment} we discuss the verification of the internal integrity of the metamodel, the ability to validate URDAD models for completeness and consistency, and assess certain metamodel qualities such as complexity, traceability and validatability. Section \ref{sec:conclusionsAndOutlook} concludes and presents an outlook on future work.\todo{AP: Rearrange sections accordingly.}
