\section{Introduction}

\emph{AP: This sentence spans 10 lines!}
Poor requirements quality is still the main cause of system errors \cite{heck_experiences_2008,_strategies_2011}. Besides intrinsic uncertainty and misinterpretation by requirements specialists or domain experts, there are other factors that contribute to defects in the requirements specification. These factors include the use of specification techniques with informal or vaguely defined requirements semantics \cite{ferguson_empirical_2006}. Specifying requirements only at a single or insufficient level of granularity, leaving developers to specify lower level requirements \cite{espana_evaluating_2009, getBetterReference}. The inability to validate requirements for consistency and completeness \cite{somebodyPleaseFindASuitableReference} and the inability to test whether an implementation fulfills the requirements (nontestable requirements) \cite{bashardoust-tajali_extracting_2008}.

Model-Driven Engineering (MDE)  \cite{schmidt_model_2006} aims to address some of these issues by using modeling languages with defined semantics, by requiring primary models to be domain models and not a technical models \cite{asnina_computation_2010}, and by providing tool support for MDE processes. As a result technology-neutral domain models are developed by requirements specialists and not by technical experts \cite{asnina_computation_2010}. In the case of an enterprise system development, requirement specialists are represented by business analysts.

The {\em Object Management Group} (OMG) is an industry standards body which has, in the context of its {\em Model Driven Architecture} (MDA) \cite{siegel_developing_2001}, introduced and standardized a number of techniques, which aim to practically facilitate {\em Model-Driven Development} (MDD) \cite{}. These include the {\em Meta-Object Facility} (MOF)  \cite{_meta_2006} for specifying modeling languages, the {\em Unified Modeling Language} (UML) \cite{_uml_2010,_uml_2010-1} as a candidate for a generic modeling language, the {\em Object Constraint Language} (OCL) \cite{_object_2010} used to specify constraints at the metamodel or model levels, {\em Query View Transformation} (QVT) \cite{_meta_2011} for model-to-model transformations and {\em MOF Model to Text Transformation Language} (MOFM2T) \cite{_mof_2008} for generating textual artifacts such as program source code or documentation. 

URDAD, the {\em Use-Case, Responsibility-Driven Analysis and Design} \cite{fritz_solms_technology_2007} aims to provide a method supporting MDE \cite{solms_urdad_2010}. It is used by requirements specialists (e.g., business analysts) to develop and validate a technology neutral requirements model. The model can be viewed as the {\em Platform Independent Model} (PIM) of the {\em Model Driven Architecture} (MDA) \cite{solms_urdad_2010}.

\emph{AP:}
URDAD is a semi-formal services-oriented requirements analysis and technology-neutral process design methodology. It recursively decomposes requirements for a service into a tree of lower level service requirements, where processes from lower level services realize higher level service contracts. Thus, instead of having service requirements at a single level of granularity with complex pre- and post-conditions, the requirements are made more manageable through recursive decomposition into lower level services, each with their own pre-and post conditions.

\emph{Fritz: want to still consolidate the concepts of the version of the paragraph shown below with those of the previous version of this paragraph shown above}
In its core, URDAD is a semi-formal services-oriented method for requirements analysis and technology-neutral process design. It recursively decomposes requirements for a service into a tree of lower level service requirements orchestrating, at any level of granularity, the process from lower level services realizing services contracts. Thus, instead of having service requirements at a single level of granularity with complex pre- and post-conditions, the requirements are made more manageable through recursive decomposition into lower level services, which have their own pre-and post conditions and their own process specifications linking them to the requirements at the yet next lower level of granularity.

The URDAD methodology is independent of the technology used to encode the semantics of an URDAD model. Working within OMG/MDA standards, one has a number of options for encoding an URDAD model. Three encoding options have been considered. The different encoding options are not mutually exclusive and several may be concurrently utilized if each offers its own unique advantages. For example, one particular encoding option may make it easier to represent semantics and reason about the model, while another encoding option may be aligned with standards and offer extensive tool support for model tool smiths and practitioners. 

The first option which has been traditionally used by requirements specialists is to encode an URDAD model using a generic language like the Unified Model Language (UML). UML is a natural choice due to its wide spread adoption in industry and comprehensive tool support. URDAD semantics and model structure constraints are provided through an URDAD profile and user discipline.  However, the burden to only use the URDAD subset of UML and to obey URDAD model semantics is put on the domain experts. Also, a complete URDAD UML profile would contain a plethora of OCL constraints, which constrain the resultant domain model to a valid URDAD model. The bulk and complexity of these constraints impose significant modeling challenges. The modeling complexity and the incomplete constraints set resulted in high costs around developing and validating domain models and high model defect densities \cite{}. Commonly, even the aim of developing an URDAD model with model integrity is abandoned in favour of supplying a sufficient requirements model for manual processing by developers.

Alternatively one can define a {\em Domain Specific Language} (DSL) for URDAD. The domain of an URDAD DSL is essentially that of technology-neutral, services-oriented requirements modeling. There are a number of compelling advantages to this approach. Firstly, the resultant language is a fraction of the size of UML and introduces exactly the semantics required by URDAD. This results in considerably lower model complexity and, with the appropriate tools, simplifies the process through which requirements specialists construct requirements models. Since only the required semantics are introduced, one also needs to specify a much smaller set of  meta-model constraints for the validation of instance models -- both for conformance to an URDAD model as well as for completeness and consistency.

A DSL introduces domain specific concepts and relationships between them. These can be introduced via a metamodel using MOF/EMOF or by defining an ontology. Either of the approaches has its benefits. An ontology specifies the semantics more formally and simplifies the formal assessment of the metamodel as well as model instances. On the other hand, a MOF/EMOF based approach benefits from very rich MDA tool set available for model-to-model and model-to-text transformations and the specification and/or generation of concrete text and diagrammatic syntaxes and tools supporting these \cite{gronback_model_2008}. In particular, the Eclipse Modeling Project has aligned its modeling tools with the OMG standards.

In this paper we explore the URDAD DSL option. We analyze the modeling constructs required by URDAD, define and critically assess an EMOF/Ecore metamodel which is able to capture the semantics required by URDAD, compare model qualities for an URDAD-DSL encoded model to a corresponding UMl encoded model and introduce a concrete text syntax enabling requirements specialists to capture a requirements model in this domain-specific language providing tools for metamodeling, model transformations, model validation and the generation of model editors which perform syntax checking against the DSL.

The paper is structured as follows. In section \ref{sec:urdadMethodology} we provide a compact overview of the URDAD method. Section \ref{sec:metamodel} introduces the URDAD metamodel, its core concepts and the rationale behind it. In section \ref{sec:example}, we present an example of an URDAD model. In section \ref{sec:metamodelAssessment} we discuss the verification of the internal integrity of the metamodel, the ability to validate URDAD models for completeness and consistency, and assess certain metamodel qualities such as complexity, traceability and validatability. Section \ref{sec:tools} discusses URDAD tools and introduces and exemplary text syntax for encoding URDAD models. In Section \ref{sec:relatedWork}, we discuss related work. Section \ref{sec:conclusionsAndOutlook} concludes and presents an outlook on future work.
