\section{Introduction}

\emph{AP: This sentence spans 10 lines!}
Poor requirements quality is still the main cause of system errors \cite{heck_experiences_2008}. Besides intrinsic uncertainty and misunderstandings of the requirements specialists or domain experts, some of the core factors that contribute to defects in the requirements specification include using specification techniques with informal or vaguely defined requirements semantics \cite{ferguson_empirical_2006}, specifying requirements only at a single or insufficient level of granularity with a lot of the lower level detailed business requirements being left to the developers \cite{espana_evaluating_2009,getBetterReference}, the inability to validate requirements for consistency and completeness \cite{somebodyPleaseFindASuitableReference}, and the inability to test whether an implementation fulfills the requirements (non-testable requirements) \cite{bashardoust-tajali_extracting_2008}.

Model-Driven Engineering (MDE)  \cite{schmidt_model_2006} aims to address some of these issues by using modeling languages with defined semantics, by requiring that the primary model should be a domain model and not a technical model\cite{asnina_computation_2010}, and by providing a set of tools which support MDE processes. The technology-neutral domain model is thus to be developed by requirements specialists and not by technical experts \cite{asnina_computation_2010}. In the case of an enterprise system development,requirement specialists are represented by business analysts.

The {\em Object Management Group} (OMG) \cite{} is an industry standards body which has, in the context of its {\em Model Driven Architecture} (MDA) \cite{siegel_developing_2001}, introduced and standardized a number of techniques, which aim to practically facilitate {\em Model-Driven Development} (MDD) \cite{}. These include the {\em Meta-Object Facility} (MOF)  \cite{} for specifying modeling languages, the {\em Unified Modeling Language} (UML) \cite{} as a candidate for a generic modeling language, the {\em Object Constraint Language} (OCL) used to specify constraints at the metamodel or model levels, {\em Query View Transformation} (QVT) for model-to-model transformations and {\em MOF Model to Text Transformation Language} (MOFM2T) for generating textual artifacts such as program source code or documentation. 

URDAD, the {\em Use-Case, Responsibility-Driven Analysis and Design} \cite{fritz_solms_technology_2007} aims to provide a method supporting MDE \cite{solms_urdad_2010}. It is used by requirements specialists (e.g., business analysts) to develop and validate a technology neutral requirements model. The requirements model can be viewed as the {\em Platform Independent Model} (PIM) of the {\em Model Driven Architecture} (MDA) \cite{solms_urdad_2010}.

\emph{AP:}
In its core, URDAD is a semi-formal services-oriented methodology for requirements analysis and technology-neutral process design. It recursively decomposes requirements for a service into a tree of lower level service requirements: processes from lower level services realize higher level service contracts. Thus, instead of having service requirements at a single level of granularity with complex pre- and post-conditions, the requirements are made more manageable through recursive decomposition into lower level services, which have their own pre-and post conditions.

\emph{Fritz: want to still consolidate the concepts of the version of the paragraph shown below with those of the previous version of this paragraph shown above}
In its core, URDAD is a semi-formal services-oriented method for requirements analysis and technology-neutral process design. It recursively decomposes requirements for a service into a tree of lower level service requirements orchestrating, at any level of granularity, the process from lower level services realizing services contracts. Thus, instead of having service requirements at a single level of granularity with complex pre- and post-conditions, the requirements are made more manageable through recursive decomposition into lower level services, which have their own pre-and post conditions and their own process specifications linking them to the requirements at the yet next lower level of granularity.

The URDAD methodology is independent of the technology used to encode the semantics of an URDAD model. Working within OMG/MDA standards, one has a number of options for encoding an URDAD model. Traditionally, requirements specialists encoded URDAD requirements models using a standard off-the-shelf UML tools enforcing model structure and qualities through an URDAD profile and user discipline. UML is a natural choice due to its wide spread adoption in industry and comprehensive tool support. However, the burden to only use the URDAD subset of UML and to obey URDAD model semantics is put on the domain experts. Also, an URDAD UML profile contains a plethora of OCL constraints, which constrain the resultant domain model to a valid URDAD model. The bulk and complexity of these constraints impose significant modeling challenges. The modeling complexity and the incomplete constraints set resulted in high costs around developing and validating domain models and high model defect densities \cite{}. Commonly, even the aim of developing an URDAD model with model integrity was abandoned in favour of supplying a sufficient requirements model for manual processing by developers.

An alternative approach is to use MOF to define a {\em Domain Specific Language} (DSL) for URDAD. The domain of an URDAD DSL is essentially that of technology-neutral, services-oriented requirements modeling. There are a number of compelling advantages to this approach. Firstly, the resultant language is a fraction of the size of UML and introduces exactly the semantics required by URDAD. This results in considerably lower model complexity and, with the appropriate tools, simplifies the process through which requirements specialists construct requirements models. Since only the required semantics are introduced, one also needs to specify a much smaller set of  meta-model constraints for the validation of instance models -- both for conformance to an URDAD model as well as for completeness and consistency.

Introducing a DSL requires that one specifies concrete text and/or diagrammatic syntaxes for the DSL. In addition one needs to either develop or generate editing/diagramming tools, which enable requirements specialists to capture an URDAD model through a concrete text or diagrammatic syntax. Using a URDAD-specific DSL requires that requirements specialists learn both the new concrete syntax as well as the tool through which the concrete syntax is captured. Finally, code, documentation and test generation tools need to be developed for the URDAD DSL. Fortunately the MDA tool suite of the {\em Eclipse Modeling Project} \cite{gronback_model_2008} facilitates the MOF metamodel-based specification of a concrete text and/or diagrammatic DSL syntax. It also supports the definition of model-to-model and model-to-text transformations and the automatic generation of editors for concrete DSL syntaxes.



In this paper we explore the URDAD DSL option. We analyze the semantics required by URDAD, define and critically assess an EMOF/Ecore metamodel which is able to capture the semantics required by URDAD, compare model qualities for an URDAD-DSL encoded model to a corresponding UMl encoded model and introduce a concrete text syntax enabling requirements specialists to capture a requirements model in this domain-specific language.

The paper is structured as follows. In section \ref{sec:urdadMethodology} we provide a compact overview of the URDAD method. Section \ref{sec:metamodel} introduces the URDAD metamodel, its core concepts and the rationale behind it. In section \ref{sec:example}, we present an example of an URDAD model. In section \ref{sec:metamodelAssessment} we discuss the verification of the internal integrity of the metamodel, the ability to validate URDAD models for completeness and consistency, and assess certain metamodel qualities such as complexity, traceability and validatability. Section \ref{sec:tools} discusses URDAD tools and introduces and exemplary text syntax for encoding URDAD models. In Section \ref{sec:relatedWork}, we discuss related work. Section \ref{sec:conclusionsAndOutlook} concludes and presents an outlook on future work.


