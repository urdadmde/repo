\section{Introduction}

\emph{AP: This sentence spans 10 lines!}
Requirements quality is the leading cause of system errors \cite{heck_experiences_2008}. Besides intrinsic uncertainty and misunderstandings of the requirements by domain experts, some of the core factors that contribute to defects in requirements specifications include using specification technologies with informal or vaguely defined requirements semantics \cite{ferguson_empirical_2006}, specifying requirements only at a single or insufficient level of granularity with a lot of the lower level detailed business requirements being left to software architects and developers
\cite{espana_evaluating_2009,getBetterReference}, the inability to validate requirements for consistency and completeness \cite{somebodyPleaseFindASuitableReference}, and the inability to test whether a solution fulfills the requirements (non-testable requirements) \cite{bashardoust-tajali_extracting_2008}.

Model-Driven Engineering (MDE) \cite{} aims to address some of these issues by using modeling languages with well defined semantics that enforce consistency across model elements by requiring that the primary model should be a domain model and not a technical model\cite{asnina_computation_2010}. Also, the MDE process is suported by a wide range of tools. The technology neutral domain model is thus to be developed by domain experts and not by technical experts \cite{asnina_computation_2010}. In the case of an enterprise system development domain experts are represented by business analysts.

The {\em Object Management Group} (OMG) \cite{} is an industry standards body which has, in the context of its {\em Model Driven Architecture} (MDA) approach \cite{siegel_developing_2001}, introduced and standardized a number of technologies, which aim to practically facilitate {\em Model-Driven Development} (MDD) \cite{}. These technologies include the {\em Meta-Object Facility} (MOF) \cite{} for specifying modeling languages, the {\em Unified Modeling Language} (UML) \cite{} as a candidate for a generic modeling language, the {\em Object Constraint Language} (OCL) for the specification of constraints at the metamodel or model levels, {\em Query View Transformation} (QVT) for model-to-model transformations and {\em MOF Model to Text Transformation Language} (MOFM2T) for the generation of textual artifacts such as source code or documentation.

URDAD ({\em Use-Case, Responsibility-Driven Analysis and Design}) \cite{solms_technology_2007} aims to provide a methodology supporting MDE. It is used by domain experts (e.g., business analysts) to develop and validate a technology neutral requirements model. The requirements model can be viewed as the {\em Platform Independent Model} (PIM) of the {\em Model Driven Architecture} (MDA) \cite{solms_urdad_2010}.

In its core, URDAD is a semi-formal services-oriented methodology for requirements analysis and technology-neutral process design. It recursively decomposes requirements for a service into a tree of lower level service requirements: processes from lower level services realize higher level service contracts. Thus, instead of having service requirements at a single level of granularity with complex pre- and post-conditions, the requirements are made more manageable through recursive decomposition into lower level services, which have their own pre-and post conditions. 

The URDAD methodology is independent of the technology used to encode the semantics of an URDAD model. Working with MDA technologies, one has intrinsically three options for encoding an URDAD model. Traditionally, domain experts encoded URDAD requirements models using standard off-the-shelf UML tools enforcing model structure and qualities through an URDAD profile and user discipline. UML is a natural choice due to its wide spread adoption in industry and comprehensive tool support. However, the burden to only use the URDAD subset of UML and to obey URDAD model semantics is put on the domain experts. Also, an URDAD UML profile contains a plethora of OCL constraints, which constrain the resultant domain model to a valid URDAD model. The bulk and the complexity of these constraints impose significant modeling challenges. The modeling complexity and the incomplete constraints set resulted in high costs around developing and validating domain models and high model defect densities \cite{}. In practice, even the aim of developing an URDAD model with model integrity was abandoned.

The second approach is to develop a front end that allows domain experts to only feed in model elements which comply with an URDAD model. The domain model would, however, still be encoded by means of a conventional UML tool. We have not pursued this approach since it would be highly dependent on the use and the availability of a particular user front end, which may be unfeasible in practice.

A third approach is to use MOF to define a {\em Domain Specific Language} (DSL) for URDAD. The domain of an URDAD DSL is essentially that of technology neutral service-oriented requirements models. There are a number of compelling advantages to this approach. Firstly, the resultant language is a fraction of the size of UML and introduces exactly the semantics required by URDAD. This results in significantly lower model complexity and, with the appropriate tools, simplifies the process through which domain experts specify requirements models. Since only the required semantics are introduced, one also needs to specify a much smaller set of meta-model constraints for the validation of instance models -- both for conformance to an URDAD model as well as for completeness and consistency.

Introducing a DSL requires that one specifies concrete text and/or diagrammatic syntaxes for the DSL. In addition, one needs to either develop or generate editing/diagramming tools, which enable domain experts to capture an URDAD model through a concrete text or diagrammatic syntax. Using an URDAD-specific DSL requires that domain experts learn both the new concrete syntax as well as the tool through which the concrete syntax is captured. Finally, code, documentation and test generation tools need to be developed for the URDAD DSL. Fortunately, the MDA tool suite of the {\em Eclipse Modeling Project} \cite{} facilitates the MOF metamodel-based specification of a concrete text and/or diagrammatic DSL syntax. It also supports the definition of model-to-model and model-to-text transformations and the automatic generation of editors for concrete DSL syntaxes.

In this paper, we explore the URDAD DSL option, focusing in particular on the introduction and critical assessment of an URDAD metamodel. The paper is structured as follows. In Section \ref{sec:urdadMethodology} we provide a compact overview of the URDAD methodology. Section \ref{sec:metamodel} introduces the URDAD metamodel, its core concepts and the rationale behind it. In Section \ref{sec:example}, we present an example of an URDAD model. In Section \ref{sec:metamodelAssessment}, we discuss the verification of the internal integrity of the metamodel, the ability to validate URDAD models for completeness and consistency, and assess certain metamodel qualities such as complexity, traceability and validatability. Section \ref{sec:tools} discusses URDAD tools and introduces and exemplary text syntax for encoding URDAD models. In Section \ref{sec:relatedWork}, we discuss related work. Section \ref{sec:conclusionsAndOutlook} concludes and presents an outlook on future work.

