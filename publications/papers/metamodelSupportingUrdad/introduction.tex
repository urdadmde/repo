\section{Introduction}

Requirements quality is still the leading cause of system errors \cite{heck_experiences_2008}. Besides intrinsic uncertainty and misunderstandings of the requirements by domain experts, some of the core factors which contribute to defects in the captures requirements specification include using specification technologies with informal or vaguely defined requirements semantics \cite{ferguson_empirical_2006}, specifying requirements only at a single or insufficient level of granularity with a lot of the lower level detailed business requirements being left to the technical team, the inability to validate requirements for consistency and completeness \cite{somebodyPleaseFindASuitableReference}, and the inability to test whether a solution fulfils the requirements (non-testable requirements) \cite{bashardoust-tajali_extracting_2008}.

Model-Driven Engineering (MDE) aims to address some of these issues by using modeling languages with defined semantics that enforce a level of consistency across model elements, by requiring that the primary model should be a domain model and not a technical model, and by providing a set of tools which support MDE processes. The technology neutral domain model is to be developed by domain experts and not by technical experts \cite{asnina_computation_2010}. In the case of an enterprise system development domain experts are represented by business analysts.

The {\em Object Management Group} (OMG) is an industry standards body which has, in the context of its {\em Model Driven Architecture} (MDA) \cite{siegel_developing_2001}, introduced and standardized a number of technologies, which aim to practically facilitate {\em Model-Driven Development} (MDD). These include the {\em Meta-Object Facility} (MOF) for specifying modeling languages, the {\em Unified Modeling Language} (UML) as a candidate for a generic modeling language, the {\em Object Constraint Language} (OCL) used to specify constraints at the metamodel or model levels, {\em Query View Transformation} (QVT) for model-to-model transformations and {\em MOF Model to Text Transformation Language} (MOFM2T) for generation of textual artefacts such as source code or documentation. 

URDAD, the {\em Use-Case, Responsibility-Driven Analysis and Design} \cite{solms_technology_2007} methodology is used by business analysts to develop and validate a technology neutral requirements model and to generate text-based documentation from the domain model. The requirements model can be viewed as the {\em Platform Independent Model} (PIM) of the {\em Model Driven Architecture} (MDA) \cite{solms_urdad_2010}.

URDAD is fundamentally a semi-formal services-oriented methodology, which recursively decomposes requirements for a service into a tree of lower level service requirements. Thus, instead of having service requirements at a single level of granularity with complex pre- and post-conditions, the requirements are made more manageable through recursive decomposition into lower level services, which have their own pre-and post conditions and the specification of how processes are orchestrated across the lower level services. Note that, even though it is compelling to mirror the service requirements with corresponding service implementation during the implementation mapping phase, it is important to realise that the recursive decomposition of service requirements is purely a way to manage requirements complexity, make requirements more manageable and facilitate the reuse of requirements components. One could, in fact, roll up the pre-and post conditions across the lower level of granularity services and the corresponding process requirements into a single, flat level of granularity resulting in more complex pre-and post-conditions at a single level of granularity.

The URDAD methodology is independent of the technology used to encode the semantics of an URDAD model. Working within MDA technologies, one has intrinsically three options for encoding an URDAD model. Traditionally domain experts encoded URDAD requirements models using a standard UML tool enforcing model structure and qualities through an URDAD profile. UML is a natural choice due to its wide spread adoption in industry and strong tool support. However, this approach puts a lot of burden on domain experts to work within the subset of UML required by URDAD and to feed in the appropriate semantics into the model. It also requires an URDAD profile with extensive OCL constraints which constrain the resultant domain model to a valid URDAD model, though the bulk and complexity of these constraints posed significant challenges. The modeling complexity and the incomplete constraints set resulted in high costs around developing and validating domain models and high model defect densities. At times, even the aim of developing an URDAD model with model integrity was abandoned.

The second approach is to develop a front end which only allows domain experts to feed in model elements which comply to an URDAD model. The generated and persisted domain model would still be encoded through a UML tool. We have not pursued this approach.

A third approach is to use MOF to define a {\em Domain Specific Language} (DSL) for URDAD. The domain is essentially that of a technology neutral services oriented requirements model. There are a number of compelling advantages to this approach. Firstly, the resultant language is a fraction of the size of UML and introduces precisely the semantics required by URDAD. This results in significantly lower model complexity and, with the appropriate tools, simplifies the process through which domain experts specify requirements models. Since only the required semantics are introduced, one also needs to specify a much smaller set of meta-model constraints, which can be used to validate the resultant instance models, both for conformance to an URDAD model, as well as for completeness and consistency.

Furthermore, introducing a DSL requires that one specifies concrete text and/or diagrammatic syntaxes for the DSL. In addition one needs to either develop or generate editing/diagramming tools, which capture an URDAD model through a concrete text or diagrammatic syntax. Using a URDAD-specific DSL also requires that domain experts learn both, the new concrete syntax as well as the tool through which the concrete syntax is captured. Finally, it requires code, documentation and test generation tools to be developed for the URDAD DSL. Fortunately the MDA tool suite and a range of support tools built around this tool suite (particularly in the context of the {\em Eclipse Modeling Project}) make it relatively easy to specify a concrete text and/or diagrammatic syntax for a DSL based on a MOF metamodel, to define model-to-model and model-to-text transformations and to generate editors for concrete DSL syntaxes.

This paper is structured as follows. In section \ref{sec:urdadMethodology} we provide a compact overview of the URDAD methodology. Section \ref{sec:metamodel} introduces the URDAD metamodel, its core concepts and the rationale behind it. In section \ref{sec:metamodelAssessment} we discuss the verification of the internal integrity of the metamodel, the ability to validate URDAD models for completeness and consistency and assess certain metamodel qualities like complexity, traceability, validatability. Section \ref{sec:tools} discusses URDAD tools and introduces and example text syntax for encoding an URDAD model. In section \ref{sec:relatedWork} we discuss related work whilst section \ref{sec:conclusionsAndOutlook} draws some conclusions and discusses the outlook for future work.

