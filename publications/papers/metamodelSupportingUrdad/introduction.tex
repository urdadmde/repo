\section{Introduction}

Poor requirements quality is still the main cause of system errors \cite{heck_experiences_2008}. Besides intrinsic uncertainty and misunderstandings of the requirements specialists or domain experts themselves, some of the core factors which contribute to defects in the captured requirements specification include using specification techniques with informal or vaguely defined requirements semantics \cite{ferguson_empirical_2006}, specifying requirements only at a single or insufficient level of granularity with a lot of the lower level detailed business requirements being left to the developers \cite{espana_evaluating_2009,getBetterReference}, the inability to validate requirements for consistency and completeness \cite{somebodyPleaseFindASuitableReference}, and the inability to test whether an implementation fulfills the requirements (non-testable requirements) \cite{bashardoust-tajali_extracting_2008}.

Model-Driven Engineering (MDE) aims to address some of these issues by using modeling languages with defined semantics, by requiring that the primary model should be a domain model and not a technical model\cite{asnina_computation_2010}, and by providing a set of tools which support MDE processes. The technology-neutral domain model is thus to be developed by requirements specialists and not by technical experts \cite{asnina_computation_2010}. In the case of an enterprise system development,requirement specialists are represented by business analysts.

The {\em Object Management Group} (OMG) is an industry standards body which has, in the context of its {\em Model Driven Architecture} (MDA) \cite{siegel_developing_2001}, introduced and standardized a number of techniques, which aim to practically facilitate {\em Model-Driven Development} (MDD). These include the {\em Meta-Object Facility} (MOF) for specifying modeling languages, the {\em Unified Modeling Language} (UML) as a candidate for a generic modeling language, the {\em Object Constraint Language} (OCL) used to specify constraints at the metamodel or model levels, {\em Query View Transformation} (QVT) for model-to-model transformations and {\em MOF Model to Text Transformation Language} (MOFM2T) for generating textual artifacts such as program source code or documentation. 

URDAD, the {\em Use-Case, Responsibility-Driven Analysis and Design} \cite{solms_technology_2007} aims to provide a method supporting MDE \cite{solms_urdad_2010}. It is used by requirements specialists (e.g. business analysts) to develop and validate a technology neutral requirements model. The requirements model can be viewed as the {\em Platform Independent Model} (PIM) of the {\em Model Driven Architecture} (MDA) \cite{solms_urdad_2010}.

In its core, URDAD is a semi-formal services-oriented method for requirements analysis and technology-neutral process design. It recursively decomposes requirements for a service into a tree of lower level service requirements orchestrating, at any level of granularity, the process from lower level services realizing services contracts. Thus, instead of having service requirements at a single level of granularity with complex pre- and post-conditions, the requirements are made more manageable through recursive decomposition into lower level services, which have their own pre-and post conditions and the specification of how processes are orchestrated across these lower level services. 

The URDAD methodology is independent of the technology used to encode the semantics of an URDAD model. Working within OMG/MDA standards, one has a number of options for encoding an URDAD model. Traditionally requirements specialists encoded URDAD requirements models using a standard UML tool enforcing model structure and qualities through an URDAD profile and user discipline. UML is a natural choice due to its wide spread adoption in industry and strong tool support. However, this approach puts a lot of burden on requirements specialists to work within the subset of UML required by URDAD and to specify additional semantic relationships required by URDAD. The task can be simplified somewhat for requirements specialists by supplying an URDAD profile with extensive OCL constraints which constrain the resultant domain model to a valid URDAD model. However, the bulk and complexity of the required constraints posed significant challenges. The modeling complexity and the incomplete constraints set resulted in high costs around developing and validating domain models and high model defect densities. Commonly, even the aim of developing an URDAD model with model integrity was abandoned in favour of supplying a sufficient requirements model for manual processing by developers.

An alternative approach is to use MOF to define a {\em Domain Specific Language} (DSL) for URDAD. The domain is essentially that of technology-neutral, services-oriented requirements modeling. There are a number of compelling advantages to this approach. Firstly, the resultant language is a fraction of the size of UML and introduces precisely the semantics required by URDAD. This results in considerably lower model complexity and, with the appropriate tools, simplifies the process through which requirements specialists construct requirements models. Since only the required semantics are introduced, one also needs to specify a much smaller set of meta-model constraints, which can be used to validate the resultant instance models, both for conformance to an URDAD model, as well as for completeness and consistency.

Furthermore, introducing a DSL requires that one specifies concrete text and/or diagrammatic syntaxes for the DSL. In addition one needs to either develop or generate editing/diagramming tools, which enable requirements specialists to capture an URDAD model through a concrete text or diagrammatic syntax. Using a URDAD-specific DSL also requires that requirements specialists learn both, the new concrete syntax as well as the tool through which the concrete syntax is captured. Finally, it requires code, documentation and test generation tools to be developed for the URDAD DSL. Fortunately the MDA tool suite and a range of support tools built around this tool suite (particularly in the context of the {\em Eclipse Modeling Project}) make it relatively easy to specify a concrete text and/or diagrammatic syntax for a DSL based on a MOF metamodel, to define model-to-model and model-to-text transformations and to generate editors for concrete DSL syntaxes \cite{gronback_model_2008,}.

In this paper we explore the URDAD DSL option. We analyze the semantics required by URDAD, define an EMOF/Ecore metamodel which is able to capture the semantics required by URDAD, compare model qualities for an URDAD-DSL encoded model to a corresponding UMl encoded model and introduce a concrete text syntax enabling requirements specialists to capture a requirements model in this domain-specific language.

The paper is structured as follows. In section \ref{sec:urdadMethodology} we provide a compact overview of the URDAD method. Section \ref{sec:metamodel} introduces the URDAD metamodel, its core concepts and the rationale behind it and in section \ref{sec:example} we present an example of an URDAD model. In section \ref{sec:metamodelAssessment} we discuss  the ability to validate URDAD models for consistency, limited completeness tests and assess certain metamodel qualities like complexity, traceability, validatability. Section \ref{sec:tools} discusses URDAD tools and introduces and example text syntax for encoding an URDAD model. In section \ref{sec:relatedWork} we discuss related work whilst section \ref{sec:conclusionsAndOutlook} draws some conclusions and discusses the outlook for future work.
